{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport _regeneratorRuntime from \"C:/Users/Owini/OneDrive/Desktop/NFTYVacation/my-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"C:/Users/Owini/OneDrive/Desktop/NFTYVacation/my-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\nvar _jsxFileName = \"C:\\\\Users\\\\Owini\\\\OneDrive\\\\Desktop\\\\NFTYVacation\\\\my-app\\\\src\\\\components\\\\Hero\\\\RenderButton.js\",\n    _this = this,\n    _s = $RefreshSig$();\n\nimport { React, useEffect, useRef, useState } from 'react';\nimport Button from '../../styles/GlobalComponents/Button';\nimport Web3Modal from 'web3modal';\nimport { providers, Contract } from \"ethers\"; //  // walletConnected keep track of whether the user's wallet is connected or not\n//  const [walletConnected, setWalletConnected] = useState(false);\n//  // Create a reference to the Web3 Modal (used for connecting to Metamask) which persists as long as the page is open\n//  const web3ModalRef = useRef();\n//  /**\n//    * Returns a Provider or Signer object representing the Ethereum RPC with or without the\n//    * signing capabilities of metamask attached\n//    *\n//    * A `Provider` is needed to interact with the blockchain - reading transactions, reading balances, reading state, etc.\n//    *\n//    * A `Signer` is a special type of Provider used in case a `write` transaction needs to be made to the blockchain, which involves the connected account\n//    * needing to make a digital signature to authorize the transaction being sent. Metamask exposes a Signer API to allow your website to\n//    * request signatures from the user using Signer functions.\n//    *\n//    * @param {*} needSigner - True if you need the signer, default false otherwise\n//    */\n//  const getProviderOrSigner = async (needSigner = false) => {\n//   // Connect to Metamask\n//   // Since we store `web3Modal` as a reference, we need to access the `current` value to get access to the underlying object\n//   const provider = await web3ModalRef.current.connect();\n//   const web3Provider = new providers.Web3Provider(provider);\n//   // If user is not connected to the Rinkeby network, let them know and throw an error\n//   const { chainId } = await web3Provider.getNetwork();\n//   if (chainId !== 4) {\n//     window.alert(\"Change the network to Rinkeby\");\n//     throw new Error(\"Change network to Rinkeby\");\n//   }\n//   if (needSigner) {\n//     const signer = web3Provider.getSigner();\n//     return signer;\n//   }\n//   return web3Provider;\n// };\n//   /*\n//     connectWallet: Connects the MetaMask wallet\n//   */\n//     const connectWallet = async () => {\n//       try {\n//         // Get the provider from web3Modal, which in our case is MetaMask\n//         // When used for the first time, it prompts the user to connect their wallet\n//         await getProviderOrSigner();\n//         setWalletConnected(true);\n//       } catch (err) {\n//         console.error(err);\n//       }\n//     };\n//     // useEffects are used to react to changes in state of the website\n//   // The array at the end of function call represents what state changes will trigger this effect\n//   // In this case, whenever the value of `walletConnected` changes - this effect will be called\n//   useEffect(() => {\n//     // if wallet is not connected, create a new instance of Web3Modal and connect the MetaMask wallet\n//     if (!walletConnected) {\n//       // Assign the Web3Modal class to the reference object by setting it's `current` value\n//       // The `current` value is persisted throughout as long as this page is open\n//       web3ModalRef.current = new Web3Modal({\n//         network: \"rinkeby\",\n//         providerOptions: {},\n//         disableInjectedProvider: false,\n//       });\n//       connectWallet();\n//     }\n//   }, [walletConnected]);\n\nvar RenderButton = function RenderButton() {\n  _s();\n\n  var _useState = useState(false),\n      walletConnected = _useState[0],\n      setWalletConnected = _useState[1];\n\n  var web3ModalRef = useRef(); // loading is set to true when we are waiting for a transaction to get mined\n\n  var _useState2 = useState(false),\n      loading = _useState2[0],\n      setLoading = _useState2[1];\n  /**\r\n    * Returns a Provider or Signer object representing the Ethereum RPC with or without the\r\n    * signing capabilities of metamask attached\r\n    *\r\n    * A `Provider` is needed to interact with the blockchain - reading transactions, reading balances, reading state, etc.\r\n    *\r\n    * A `Signer` is a special type of Provider used in case a `write` transaction needs to be made to the blockchain, which involves the connected account\r\n    * needing to make a digital signature to authorize the transaction being sent. Metamask exposes a Signer API to allow your website to\r\n    * request signatures from the user using Signer functions.\r\n    *\r\n    * @param {*} needSigner - True if you need the signer, default false otherwise\r\n    */\n\n\n  var getProviderOrSigner = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var needSigner,\n          provider,\n          web3Provider,\n          _yield$web3Provider$g,\n          chainId,\n          signer,\n          _args = arguments;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              needSigner = _args.length > 0 && _args[0] !== undefined ? _args[0] : false;\n              _context.next = 3;\n              return web3ModalRef.current.connect();\n\n            case 3:\n              provider = _context.sent;\n              web3Provider = new providers.Web3Provider(provider); // If user is not connected to the Rinkeby network, let them know and throw an error\n\n              _context.next = 7;\n              return web3Provider.getNetwork();\n\n            case 7:\n              _yield$web3Provider$g = _context.sent;\n              chainId = _yield$web3Provider$g.chainId;\n\n              if (!(chainId !== 4)) {\n                _context.next = 12;\n                break;\n              }\n\n              window.alert(\"Change the network to Rinkeby\");\n              throw new Error(\"Change network to Rinkeby\");\n\n            case 12:\n              if (!needSigner) {\n                _context.next = 15;\n                break;\n              }\n\n              signer = web3Provider.getSigner();\n              return _context.abrupt(\"return\", signer);\n\n            case 15:\n              return _context.abrupt(\"return\", web3Provider);\n\n            case 16:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function getProviderOrSigner() {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  /*\r\n    connectWallet: Connects the MetaMask wallet\r\n  */\n\n\n  var connectWallet = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.prev = 0;\n              _context2.next = 3;\n              return getProviderOrSigner();\n\n            case 3:\n              setWalletConnected(true);\n              _context2.next = 9;\n              break;\n\n            case 6:\n              _context2.prev = 6;\n              _context2.t0 = _context2[\"catch\"](0);\n              console.error(_context2.t0);\n\n            case 9:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[0, 6]]);\n    }));\n\n    return function connectWallet() {\n      return _ref2.apply(this, arguments);\n    };\n  }(); // useEffects are used to react to changes in state of the website\n  // The array at the end of function call represents what state changes will trigger this effect\n  // In this case, whenever the value of `walletConnected` changes - this effect will be called\n\n\n  useEffect(function () {\n    // if wallet is not connected, create a new instance of Web3Modal and connect the MetaMask wallet\n    if (!walletConnected) {\n      // Assign the Web3Modal class to the reference object by setting it's `current` value\n      // The `current` value is persisted throughout as long as this page is open\n      web3ModalRef.current = new Web3Modal({\n        network: \"rinkeby\",\n        providerOptions: {},\n        disableInjectedProvider: false\n      });\n      connectWallet();\n    }\n  }, [walletConnected]);\n\n  if (walletConnected) {\n    if (loading) {\n      return /*#__PURE__*/_jsxDEV(Button, {\n        children: \"Loading...\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 162,\n        columnNumber: 16\n      }, _this);\n    } else {\n      return /*#__PURE__*/_jsxDEV(Button, {\n        onClick: connectWallet,\n        children: \"Connect your wallet\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 165,\n        columnNumber: 11\n      }, _this);\n    }\n  }\n\n  return /*#__PURE__*/_jsxDEV(Button, {\n    children: \"Mint\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 172,\n    columnNumber: 9\n  }, _this);\n};\n\n_s(RenderButton, \"pwrAwq4HVKwSs7YLLnBtdzbkfrk=\");\n\n_c = RenderButton;\nexport default RenderButton;\n\nvar _c;\n\n$RefreshReg$(_c, \"RenderButton\");","map":{"version":3,"sources":["C:/Users/Owini/OneDrive/Desktop/NFTYVacation/my-app/src/components/Hero/RenderButton.js"],"names":["React","useEffect","useRef","useState","Button","Web3Modal","providers","Contract","RenderButton","walletConnected","setWalletConnected","web3ModalRef","loading","setLoading","getProviderOrSigner","needSigner","current","connect","provider","web3Provider","Web3Provider","getNetwork","chainId","window","alert","Error","signer","getSigner","connectWallet","console","error","network","providerOptions","disableInjectedProvider"],"mappings":"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","sourcesContent":["import {React, useEffect, useRef, useState} from 'react';\r\nimport Button from '../../styles/GlobalComponents/Button';\r\nimport Web3Modal from 'web3modal';\r\nimport { providers, Contract } from \"ethers\";\r\n\r\n//  // walletConnected keep track of whether the user's wallet is connected or not\r\n \r\n \r\n//  const [walletConnected, setWalletConnected] = useState(false);\r\n\r\n//  // Create a reference to the Web3 Modal (used for connecting to Metamask) which persists as long as the page is open\r\n//  const web3ModalRef = useRef();\r\n\r\n\r\n\r\n\r\n//  /**\r\n//    * Returns a Provider or Signer object representing the Ethereum RPC with or without the\r\n//    * signing capabilities of metamask attached\r\n//    *\r\n//    * A `Provider` is needed to interact with the blockchain - reading transactions, reading balances, reading state, etc.\r\n//    *\r\n//    * A `Signer` is a special type of Provider used in case a `write` transaction needs to be made to the blockchain, which involves the connected account\r\n//    * needing to make a digital signature to authorize the transaction being sent. Metamask exposes a Signer API to allow your website to\r\n//    * request signatures from the user using Signer functions.\r\n//    *\r\n//    * @param {*} needSigner - True if you need the signer, default false otherwise\r\n//    */\r\n//  const getProviderOrSigner = async (needSigner = false) => {\r\n//   // Connect to Metamask\r\n//   // Since we store `web3Modal` as a reference, we need to access the `current` value to get access to the underlying object\r\n//   const provider = await web3ModalRef.current.connect();\r\n//   const web3Provider = new providers.Web3Provider(provider);\r\n\r\n\r\n\r\n//   // If user is not connected to the Rinkeby network, let them know and throw an error\r\n//   const { chainId } = await web3Provider.getNetwork();\r\n//   if (chainId !== 4) {\r\n//     window.alert(\"Change the network to Rinkeby\");\r\n//     throw new Error(\"Change network to Rinkeby\");\r\n//   }\r\n\r\n//   if (needSigner) {\r\n//     const signer = web3Provider.getSigner();\r\n//     return signer;\r\n//   }\r\n//   return web3Provider;\r\n// };\r\n\r\n//   /*\r\n//     connectWallet: Connects the MetaMask wallet\r\n//   */\r\n//     const connectWallet = async () => {\r\n//       try {\r\n//         // Get the provider from web3Modal, which in our case is MetaMask\r\n//         // When used for the first time, it prompts the user to connect their wallet\r\n//         await getProviderOrSigner();\r\n//         setWalletConnected(true);\r\n  \r\n//       } catch (err) {\r\n//         console.error(err);\r\n//       }\r\n//     };\r\n\r\n//     // useEffects are used to react to changes in state of the website\r\n//   // The array at the end of function call represents what state changes will trigger this effect\r\n//   // In this case, whenever the value of `walletConnected` changes - this effect will be called\r\n//   useEffect(() => {\r\n//     // if wallet is not connected, create a new instance of Web3Modal and connect the MetaMask wallet\r\n//     if (!walletConnected) {\r\n//       // Assign the Web3Modal class to the reference object by setting it's `current` value\r\n//       // The `current` value is persisted throughout as long as this page is open\r\n//       web3ModalRef.current = new Web3Modal({\r\n//         network: \"rinkeby\",\r\n//         providerOptions: {},\r\n//         disableInjectedProvider: false,\r\n//       });\r\n//       connectWallet();\r\n//     }\r\n//   }, [walletConnected]);\r\n\r\n\r\n  const RenderButton = () => {\r\n\r\n     const [walletConnected, setWalletConnected] = useState(false);\r\n\r\n      const web3ModalRef = useRef();\r\n\r\n        // loading is set to true when we are waiting for a transaction to get mined\r\n  const [loading, setLoading] = useState(false);\r\n\r\n /**\r\n   * Returns a Provider or Signer object representing the Ethereum RPC with or without the\r\n   * signing capabilities of metamask attached\r\n   *\r\n   * A `Provider` is needed to interact with the blockchain - reading transactions, reading balances, reading state, etc.\r\n   *\r\n   * A `Signer` is a special type of Provider used in case a `write` transaction needs to be made to the blockchain, which involves the connected account\r\n   * needing to make a digital signature to authorize the transaction being sent. Metamask exposes a Signer API to allow your website to\r\n   * request signatures from the user using Signer functions.\r\n   *\r\n   * @param {*} needSigner - True if you need the signer, default false otherwise\r\n   */\r\n const getProviderOrSigner = async (needSigner = false) => {\r\n  // Connect to Metamask\r\n  // Since we store `web3Modal` as a reference, we need to access the `current` value to get access to the underlying object\r\n  const provider = await web3ModalRef.current.connect();\r\n  const web3Provider = new providers.Web3Provider(provider);\r\n\r\n\r\n\r\n  // If user is not connected to the Rinkeby network, let them know and throw an error\r\n  const { chainId } = await web3Provider.getNetwork();\r\n  if (chainId !== 4) {\r\n    window.alert(\"Change the network to Rinkeby\");\r\n    throw new Error(\"Change network to Rinkeby\");\r\n  }\r\n\r\n  if (needSigner) {\r\n    const signer = web3Provider.getSigner();\r\n    return signer;\r\n  }\r\n  return web3Provider;\r\n};\r\n\r\n  /*\r\n    connectWallet: Connects the MetaMask wallet\r\n  */\r\n    const connectWallet = async () => {\r\n      try {\r\n        // Get the provider from web3Modal, which in our case is MetaMask\r\n        // When used for the first time, it prompts the user to connect their wallet\r\n        await getProviderOrSigner();\r\n        setWalletConnected(true);\r\n  \r\n      } catch (err) {\r\n        console.error(err);\r\n      }\r\n    };\r\n\r\n    // useEffects are used to react to changes in state of the website\r\n  // The array at the end of function call represents what state changes will trigger this effect\r\n  // In this case, whenever the value of `walletConnected` changes - this effect will be called\r\n  useEffect(() => {\r\n    // if wallet is not connected, create a new instance of Web3Modal and connect the MetaMask wallet\r\n    if (!walletConnected) {\r\n      // Assign the Web3Modal class to the reference object by setting it's `current` value\r\n      // The `current` value is persisted throughout as long as this page is open\r\n      web3ModalRef.current = new Web3Modal({\r\n        network: \"rinkeby\",\r\n        providerOptions: {},\r\n        disableInjectedProvider: false,\r\n      });\r\n      connectWallet();\r\n    }\r\n  }, [walletConnected]);\r\n\r\n\r\n    if (walletConnected) {\r\n      if (loading) {\r\n        return <Button>Loading...</Button>;\r\n      } else {\r\n        return (\r\n          <Button onClick={connectWallet}>\r\n          Connect your wallet\r\n        </Button>\r\n        );\r\n      }\r\n    }\r\n      return (\r\n        <Button>\r\n          Mint\r\n        </Button>\r\n      );\r\n    };\r\n\r\nexport default RenderButton"]},"metadata":{},"sourceType":"module"}